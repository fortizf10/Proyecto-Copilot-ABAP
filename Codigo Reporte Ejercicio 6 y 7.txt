*&---------------------------------------------------------------------*
*& Report ZFI_OPEN_ITEMS_REPORT
*&---------------------------------------------------------------------*
REPORT ZTEST_COPILOT_EO_6.

" Estructura para los filtros de selección del reporte
TYPES: BEGIN OF ty_selection,
         bukrs      TYPE bukrs,       " Sociedad
         budat_low  TYPE budat,       " Fecha contabilización inicial
         budat_high TYPE budat,       " Fecha contabilización final
       END OF ty_selection.

" Estructura para los datos del reporte
TYPES: BEGIN OF ty_fi_open_item,
         bukrs       TYPE bukrs,      " Sociedad
         partner     TYPE char10,     " Cliente/Proveedor
         name1       TYPE name1_gp,   " Nombre del interlocutor
         belnr       TYPE belnr_d,    " Documento contable
         budat       TYPE budat,      " Fecha de contabilización
         bldat       TYPE bldat,      " Fecha del documento
         waers       TYPE waers,      " Moneda original
         wrbtr       TYPE wrbtr,      " Importe original
         days_open   TYPE i,          " Días abiertos
         aging_cat   TYPE char10,     " Categoría de antigüedad
         status_icon TYPE icon_d,     " Semáforo
       END OF ty_fi_open_item.

       "estructura generada para la clase de conversion de moneda.
  TYPES: BEGIN OF ty_conversion_params,
         amount_from   TYPE wrbtr,    " Importe a convertir
         currency_from TYPE waers,   " Moneda origen
         currency_to   TYPE waers,   " Moneda destino
         conv_date     TYPE budat,   " Fecha para tipo de cambio
         exch_type     TYPE tcurr-kurst, " Tipo de cambio
         company_code  TYPE bukrs,   " Sociedad
       END OF ty_conversion_params.

   TYPES: BEGIN OF ty_conversion_result,
         amount_to     TYPE wrbtr,    " Importe convertido
         status        TYPE char1,    " Estado (S=Success, E=Error, W=Warning)
         message       TYPE string,   " Mensaje de error o advertencia
       END OF ty_conversion_result.

TYPES ty_t_fi_open_item TYPE STANDARD TABLE OF ty_fi_open_item WITH EMPTY KEY.

CLASS lcl_data_access DEFINITION FINAL.
  PUBLIC SECTION.
    METHODS:
      get_open_items
        IMPORTING
          iv_bukrs      TYPE bukrs
          iv_date_from  TYPE budat
          iv_date_to    TYPE budat
        RETURNING
          VALUE(rt_items) TYPE ty_t_fi_open_item.
  PRIVATE SECTION.
    METHODS:
      fetch_customer_items
        IMPORTING
          iv_bukrs      TYPE bukrs
          iv_date_from  TYPE budat
          iv_date_to    TYPE budat
        RETURNING
          VALUE(rt_items) TYPE ty_t_fi_open_item,

       fetch_vendor_items
        IMPORTING
          iv_bukrs      TYPE bukrs
          iv_date_from  TYPE budat
          iv_date_to    TYPE budat
        RETURNING
          VALUE(rt_items) TYPE ty_t_fi_open_item,

      calculate_days_and_bucket
        CHANGING
          ct_items TYPE ty_t_fi_open_item.
ENDCLASS.

CLASS lcl_data_access IMPLEMENTATION.

  METHOD get_open_items.
    DATA(lt_customer_items) = fetch_customer_items( iv_bukrs = iv_bukrs iv_date_from = iv_date_from iv_date_to = iv_date_to ).
    DATA(lt_vendor_items) = fetch_vendor_items( iv_bukrs = iv_bukrs iv_date_from = iv_date_from iv_date_to = iv_date_to ).

    rt_items = VALUE #( BASE lt_customer_items FOR ls_vendor IN lt_vendor_items ( ls_vendor ) ).

    calculate_days_and_bucket( CHANGING ct_items = rt_items ).
  ENDMETHOD.

  METHOD fetch_customer_items.
    SELECT
      b~bukrs,
      b~kunnr AS partner,
      k~name1,
      b~belnr,
      b~budat,
      b~bldat,
      b~waers,
      b~wrbtr
    FROM bsid AS b
    INNER JOIN kna1 AS k ON k~kunnr = b~kunnr
    WHERE b~bukrs = @iv_bukrs
      AND b~budat BETWEEN @iv_date_from AND @iv_date_to
    INTO TABLE @rt_items.
  ENDMETHOD.

  METHOD fetch_vendor_items.
    SELECT
      b~bukrs,
      b~lifnr AS partner,
      l~name1,
      b~belnr,
      b~budat,
      b~bldat,
      b~waers,
      b~wrbtr
    FROM bsik AS b
    INNER JOIN lfa1 AS l ON l~lifnr = b~lifnr
    WHERE b~bukrs = @iv_bukrs
      AND b~budat BETWEEN @iv_date_from AND @iv_date_to
    INTO TABLE @rt_items.
  ENDMETHOD.

METHOD calculate_days_and_bucket.
    LOOP AT ct_items ASSIGNING FIELD-SYMBOL(<ls_item>).
      <ls_item>-days_open = sy-datum - <ls_item>-budat.

      IF <ls_item>-days_open <= 30.
        <ls_item>-aging_cat   = '0-30'.
        <ls_item>-status_icon = icon_green_light.
      ELSEIF <ls_item>-days_open <= 60.
        <ls_item>-aging_cat   = '31-60'.
        <ls_item>-status_icon = icon_yellow_light.
      ELSEIF <ls_item>-days_open <= 90.
        <ls_item>-aging_cat   = '61-90'.
        <ls_item>-status_icon = icon_light_out.
      ELSE.
        <ls_item>-aging_cat   = '>90'.
        <ls_item>-status_icon = icon_red_light.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.

ENDCLASS.

CLASS lcl_currency_converter DEFINITION FINAL.
  PUBLIC SECTION.
    METHODS:
      convert_amount
        IMPORTING
          is_params TYPE ty_conversion_params
        RETURNING
          VALUE(rs_result) TYPE ty_conversion_result.
ENDCLASS.

CLASS lcl_currency_converter IMPLEMENTATION.

  METHOD convert_amount.

  data: lv_amount_to type wrbtr.
    TRY.
        " Validar que las monedas no estén vacías
        IF is_params-currency_from IS INITIAL OR is_params-currency_to IS INITIAL.
          rs_result = VALUE ty_conversion_result(
                        status  = 'E'
                        message = 'Moneda origen o destino no puede estar vacía' ).
          RETURN.
        ENDIF.

        " Si la moneda origen es igual a la moneda destino, retornar el mismo importe
        IF is_params-currency_from = is_params-currency_to.
          rs_result = VALUE ty_conversion_result(
                        amount_to = is_params-amount_from
                        status    = 'S'
                        message   = 'Conversión no requerida, monedas iguales' ).
          RETURN.
        ENDIF.

        " Llamar a la función para conversión de moneda

        CALL FUNCTION 'CONVERT_TO_FOREIGN_CURRENCY'
          EXPORTING
            client          = sy-mandt
            date            = is_params-conv_date
            foreign_currency = is_params-currency_to
            local_currency   = is_params-currency_from
            local_amount     = is_params-amount_from
            type_of_rate     = is_params-exch_type
            rate             = is_params-conv_date
            "company_code     = is_params-company_code
          IMPORTING
            foreign_amount   = lv_amount_to
          EXCEPTIONS
            no_rate_found    = 1
            overflow         = 2
            OTHERS           = 3.

        " Manejo de errores en la conversión
        IF sy-subrc <> 0.
          DATA(lv_error_message) = COND string(
            WHEN sy-subrc = 1 THEN 'No se encontró tipo de cambio'
            WHEN sy-subrc = 2 THEN 'Desbordamiento en la conversión'
            ELSE 'Error desconocido en la conversión' ).
          rs_result = VALUE ty_conversion_result(
                        status  = 'E'
                        message = lv_error_message ).
        ELSE.
          rs_result = VALUE ty_conversion_result(
                        amount_to = lv_amount_to
                        status    = 'S'
                        message   = 'Conversión exitosa' ).
        ENDIF.

      CATCH cx_root INTO DATA(lx_error).
        rs_result = VALUE ty_conversion_result(
                      status  = 'E'
                      message = lx_error->get_text( ) ).
    ENDTRY.
  ENDMETHOD.

ENDCLASS.



*START-OF-SELECTION.
*" Prueba rápida de conversión
*DATA(lo_converter) = NEW lcl_currency_converter( ).
*
*BREAK SF500126.
*
*DATA(ls_params) = VALUE ty_conversion_params(
*  amount_from   = '1000.00'
*  currency_from = 'EUR'
*  currency_to   = 'USD'
*  conv_date     = sy-datum
*  exch_type     = 'M'
*  company_code  = '1000'
*).
*
*DATA(ls_result) = lo_converter->convert_amount( ls_params ).
*
*" Corregimos los nombres de los campos aquí:
*WRITE: / 'Importe convertido:', ls_result-amount_to. " Cambiado de amount_converted a amount_to
*WRITE: / 'Status:',             ls_result-status.
*WRITE: / 'Mensaje:',            ls_result-message.   " Cambiado de exchange_rate a message


CLASS lcl_business_logic DEFINITION FINAL.
  PUBLIC SECTION.
    METHODS:
      process_open_items
        IMPORTING
          iv_bukrs      TYPE bukrs
          iv_date_from  TYPE budat
          iv_date_to    TYPE budat
        RETURNING
          VALUE(rt_items) TYPE ty_t_fi_open_item.
  PRIVATE SECTION.
    METHODS:
      validate_parameters
        IMPORTING
          iv_bukrs      TYPE bukrs
          iv_date_from  TYPE budat
          iv_date_to    TYPE budat,

      enrich_with_conversion
        CHANGING
          ct_items TYPE ty_t_fi_open_item.
ENDCLASS.

CLASS lcl_business_logic IMPLEMENTATION.

  METHOD process_open_items.
    TRY.
        " Validar parámetros de entrada
        validate_parameters( iv_bukrs = iv_bukrs iv_date_from = iv_date_from iv_date_to = iv_date_to ).

        " Obtener datos de partidas abiertas (delegado a otra clase)
        DATA(lo_data_access) = NEW lcl_data_access( ).
        DATA(lt_items) = lo_data_access->get_open_items(
                           iv_bukrs     = iv_bukrs
                           iv_date_from = iv_date_from
                           iv_date_to   = iv_date_to ).

        " Enriquecer datos con lógica de conversión de moneda
        enrich_with_conversion( CHANGING ct_items = lt_items ).

        " Retornar los datos procesados
        rt_items = lt_items.

      CATCH cx_root INTO DATA(lx_error).
        " Manejo de errores
        MESSAGE lx_error->get_text( ) TYPE 'E'.
    ENDTRY.
  ENDMETHOD.

  METHOD validate_parameters.
    " Validar que los parámetros no estén vacíos
    IF iv_bukrs IS INITIAL OR iv_date_from IS INITIAL OR iv_date_to IS INITIAL.
      RAISE EXCEPTION TYPE cx_bo_error
        EXPORTING
          textid = 'Parámetros de entrada no válidos'.
    ENDIF.

    " Validar que la fecha inicial sea menor o igual a la fecha final
    IF iv_date_from > iv_date_to.
      RAISE EXCEPTION TYPE cx_bo_error
        EXPORTING
          textid = 'Rango de fechas no válido'.
    ENDIF.
  ENDMETHOD.

  METHOD enrich_with_conversion.
    " Crear instancia del convertidor de moneda
    DATA(lo_converter) = NEW lcl_currency_converter( ).

    " Recorrer los datos y convertir importes
    LOOP AT ct_items ASSIGNING FIELD-SYMBOL(<ls_item>).
      DATA(ls_params) = VALUE ty_conversion_params(
                          amount_from   = <ls_item>-wrbtr
                          currency_from = <ls_item>-waers
                          currency_to   = 'USD' " Moneda destino fija como ejemplo
                          conv_date     = <ls_item>-budat
                          company_code  = <ls_item>-bukrs ).

      DATA(ls_result) = lo_converter->convert_amount( ls_params ).

      " Manejar errores de conversión
      IF ls_result-status = 'E'.
        <ls_item>-status_icon = icon_red_light.
        CONTINUE.
      ENDIF.

      " Actualizar el importe convertido
      <ls_item>-wrbtr = ls_result-amount_to.
    ENDLOOP.
  ENDMETHOD.

ENDCLASS.

"UNIT-TESTS
*CLASS lcl_business_logic_test DEFINITION FINAL FOR TESTING
*  DURATION SHORT
*  RISK LEVEL HARMLESS.
*
*
*  PRIVATE SECTION.
*    DATA: lo_business_logic TYPE REF TO lcl_business_logic,
*          lt_result         TYPE ty_t_fi_open_item.
*
*    METHODS:
*      setup,
*      test_process_valid_input,
*      test_process_invalid_dates,
*      test_process_parameters.
*
*ENDCLASS.
*
*CLASS lcl_business_logic_test IMPLEMENTATION.
*
*  METHOD setup.
*    " Crear instancia de la clase bajo prueba
*    lo_business_logic = NEW lcl_business_logic( ).
*  ENDMETHOD.
*
*  METHOD test_process_valid_input.
*    " Caso de prueba con parámetros válidos
*    TRY.
*        lt_result = lo_business_logic->process_open_items(
*          iv_bukrs      = '1000'
*          iv_date_from  = '20230101'
*          iv_date_to    = '20231231' ).
*
*        " Verificar que se devuelvan resultados
*        cl_abap_unit_assert=>assert_not_initial( lt_result ).
*      CATCH cx_root INTO DATA(lx_error).
*        cl_abap_unit_assert=>fail( lx_error->get_text( ) ).
*    ENDTRY.
*  ENDMETHOD.
*
*  METHOD test_process_invalid_dates.
*    " Caso de prueba con rango de fechas inválido
*    TRY.
*        lo_business_logic->process_open_items(
*          iv_bukrs      = '1000'
*          iv_date_from  = '20231231'
*          iv_date_to    = '20230101' ).
*        cl_abap_unit_assert=>fail( 'Se esperaba una excepción para rango de fechas inválido' ).
*      CATCH cx_bo_error INTO DATA(lx_error).
*      cl_abap_unit_assert=>assert_bound( act = lx_error ).
*    ENDTRY.
*  ENDMETHOD.
*
*  METHOD test_process_parameters.
*    " Caso de prueba con parámetros faltantes
*    TRY.
*        lo_business_logic->process_open_items(
*          iv_bukrs      = ''
*          iv_date_from  = '20230101'
*          iv_date_to    = '20231231' ).
*        cl_abap_unit_assert=>fail( 'Se esperaba una excepción para parámetros faltantes' ).
*      CATCH cx_bo_error INTO DATA(lx_error).
*        cl_abap_unit_assert=>assert_bound( act = lx_error ).
*    ENDTRY.
*  ENDMETHOD.
*
*ENDCLASS.
*&---------------------------------------------------------------------*
*& Unit Tests para lcl_currency_converter
*&---------------------------------------------------------------------*
CLASS ltcl_currency_converter_test DEFINITION FINAL FOR TESTING
  DURATION SHORT
  RISK LEVEL HARMLESS.

  PRIVATE SECTION.
    DATA: f_cut TYPE REF TO lcl_currency_converter.

    METHODS:
      setup,
      test_same_currency FOR TESTING,
      test_empty_currency FOR TESTING,
      test_successful_conversion FOR TESTING.
ENDCLASS.

CLASS ltcl_currency_converter_test IMPLEMENTATION.

  METHOD setup.
    " Instanciar la clase a probar (Class Under Test)
    f_cut = NEW lcl_currency_converter( ).
  ENDMETHOD.

  METHOD test_same_currency.
    " Escenario: Convertir de EUR a EUR no debería cambiar el monto
    DATA(ls_params) = VALUE ty_conversion_params(
      amount_from   = '100.00'
      currency_from = 'EUR'
      currency_to   = 'EUR'
      conv_date     = sy-datum
    ).

    DATA(ls_result) = f_cut->convert_amount( ls_params ).

    cl_abap_unit_assert=>assert_equals(
      exp = '100.00'
      act = ls_result-amount_to
      msg = 'Si las monedas son iguales, el monto debe ser el mismo' ).

    cl_abap_unit_assert=>assert_equals(
      exp = 'S'
      act = ls_result-status
      msg = 'El estado debe ser S (Success)' ).
  ENDMETHOD.

  METHOD test_empty_currency.
    " Escenario: Moneda vacía debe retornar error
    DATA(ls_params) = VALUE ty_conversion_params(
      amount_from   = '100.00'
      currency_from = ''
      currency_to   = 'USD'
    ).

    DATA(ls_result) = f_cut->convert_amount( ls_params ).

    cl_abap_unit_assert=>assert_equals(
      exp = 'E'
      act = ls_result-status
      msg = 'Debe fallar si falta la moneda de origen' ).
  ENDMETHOD.

  METHOD test_successful_conversion.
    " Escenario: Conversión normal (requiere tipos de cambio en TCURR)
    " Nota: Este test depende de datos maestros. En un entorno real,
    " se suele usar un Double/Mock para la función CONVERT_TO_FOREIGN_CURRENCY.

    DATA(ls_params) = VALUE ty_conversion_params(
      amount_from   = '100.00'
      currency_from = 'EUR'
      currency_to   = 'USD'
      conv_date     = sy-datum
      exch_type     = 'M'
    ).

    DATA(ls_result) = f_cut->convert_amount( ls_params ).

    " Solo verificamos que no sea error, ya que el monto exacto varía por día
    IF ls_result-status = 'E'.
      " Si falla por falta de tipo de cambio en el sistema de pruebas, lanzamos aviso
      cl_abap_unit_assert=>fail( msg = 'La conversión falló. Verifique si existen tipos de cambio en TCURR' ).
    ELSE.
      cl_abap_unit_assert=>assert_not_initial(
        act = ls_result-amount_to
        msg = 'El monto convertido no debería estar vacío' ).
    ENDIF.
  ENDMETHOD.

ENDCLASS.